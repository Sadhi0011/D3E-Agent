# Models-Description

# Models

Models describe the structure of your data. More than 90% of your backend application is generated by what you describe in these models. A model represents an object containing the data of an application.

Here are some examples of Models:

1. Contact
2. Invoice
3. Receipt
4. Ticket
5. Agent and
6. User

These are the data which we store in the database depending on your application.

Usually every form you have in your application needs one or more models.
Also there are models which you normally don't see in UI, but are required to store some essential data.

Unlike SQL or Excel Sheets, which describe your data in rows and columns, D3E describes your data in terms of objects.

Every model will have a name with which it will be identified in API.

1. Properties
2. Relations
3. Validations
4. Actions
5. Access Controls
6. Others

## Creating Model

To create a model in D3E Studio, you can follow these steps:

1. Navigate to Data Section
2. Click on Models
3. In the submenu click on “Create Model” button to create a new model
   a. Give your model a appropriate name & Description for Identification

## Model Properties

If a Model is a table then property is like a column in that table. Properties define field name and field types of the object which the model is describing.

For example, in a Contact model, the name and phone number can be considered as properties of the model.

## Creating Properties

To create properties for a model, you can follow these steps:

<img src="/images/properties.png" class="team">

1. Click on Models in the Data Section
2. Select an existing model or create a new model in the model’s menu
3. In the properties section click on “Create Property” to create properties
   • The name defines the name(identity) of the property.
   • Type can be a primitive, another model or option set.

## Unique Properties

Unique properties have some values which don't allow duplicate values.

## Long Text Properties

Long text properties are suitable when the user does not know how much data to enter, so we use the long text in properties.

For example, in a resume, there will be a "Summary" section. In that section, we use the long text in properties.

## Delete Properties

You can use the OnDelete method to delete a property from a model. OnDelete is an event that is used to delete a property from a model.

| Field      | Description                                                              |
| :--------- | :----------------------------------------------------------------------- |
| Name       | Name of the property. Property identity will be derived from it          |
| Type       | Type of the property. It can be Primitive, or reference to another Model |
| Collection | If this is a single value or a List of values of specified type          |

Property type can be primitive, another model or option set.

### Primitive Types

| Type     | Default Value | Description                                                        |
| :------- | :------------ | :----------------------------------------------------------------- |
| String   | null          | For storing small or big text. Everything is stored in UTF8 format |
| Boolean  | false         | true or false                                                      |
| Integer  | 0             | Mathematical integer. It is 64 bit Signed value                    |
| Double   | 0.0           | Floating point value. 64 bit signed value                          |
| Date     | null          | To represent Date                                                  |
| Time     | null          | To represent Time                                                  |
| DateTime | null          | To represent Data and Time together.                               |
| File     | null          | Anything you want to store in a file.                              |
| Duration | null          | Represents time gap between two DateTimes                          |

### Creatable

Every model is creatable by default. For example if we create model called 'Contact',
then automatically in the generated application you will get an API to create/update/delete contacts.

```Dart
  class Mutation {
    Future<MutateContactResult> createContact(Contact value);
    Future<MutateContactResult> updateContact(Contact value);
    Future<MutateContactResult> dalteContact(Contact value);
  }
```

Non-creatable models are mainly used as internal structures of other creatable models.

For example **Address** is a non creatable model which is used as address field in **Contact** model.
In this case _address_ is a child property in **Contact**.

### Embedded

Embedded models are similar to non creatable models. But they will never be null.

```Dart
 // If Address is non embedded model
 class Contact {
   String get name;
   set name(String val);

   Address get address;
   set address(Address val);
 }
```

```Dart
 // If Address is embedded model
 class Contact {
   String get name;
   set name(String val);

   // There will always be an address in Contact and you can not set it.
   // You can only change values inside address
   Address get address;
 }
```

Embedded models are always considered as children whereever they are used.

### Collection

When a property is marked as a collection, it becomes a list of its type.

```Dart
 class Contact {
   String get name; //name is not a collection
   List<String> get names; //names is a collection property
 }
```

Collection property values will never be null. It will always be an empty list.

### Parent & Child Models

A Model can have a parent model. It is similar to extending a class in OOPs.

We should not create parent models, just because there are common fields across two models.
Not only common fields, their purpose also needs to match and there should be a requirement to have them in a common parent model.

The Model whose properties and methods are inherited is known as the "parent Model." And the model that inherits the properties from the parent class is the “Child Model”. Along with the inherited properties and methods, a child's Model can have its own properties and methods.

### Property Validations

Property Validations are rules to check before accepting a given value for a field.
If rule is not passed, then current operation (create/update) will be rejected and
given Error Message is shown in the UI.

These expressions are written in D3E.
Lets say your business rule is Invoice date can not be more than 7 days before today.

```Dart
!it.before(Date.now().subtract(Duration(days:7)))
```

Here _it_ refers to the property in which this expression is being written.
type of _it_ depends on the type of property.

### Model Validations

Model validations are similar to property validations, but they are checked at model level.
Here we can add advanced conditions that depend on more than one field of model.

```Dart
// Invoice date should be before due date
this.invoiceDate.before(this.dueDate)
```

## Validating Models

You can validate models by following these steps

1. In the data section click on the model you want to validate
2. Navigate to the “validations” section in the control toolbar
3. Click on “Create Validation” & fill the fields with appropriate information
4. Save the validation for the model

<img src="/images/validatingmodel.png" class="team">

You can make some properties required so that the property of the value must be filled, otherwise the modal will fail.

Ex: In the sign-in form, users should provide their e-mail and password values. Here, mail and password are required properties, which means if a user does not give email and password, he can not sign in.

### Actions

Only way to modify any data on the D3E Application is by invoking _create/update/delete_ methods on **Mutation** type.
There are no other ways of modifying data.

By default every creatable model will be automatically saved, updated or deleted when those requests are called.
Before that validations will be checked and only if every validation passes, then they will be saved.

Actions allow us to do any modifications to these data, and also perfom some other operations.

RunOn value tells when you want to run this particular action.

1. OnCreate
2. OnUpdate
3. OnCreateAndUpdate
4. OnDelete

Actions can be invoked due to external calls(API) or internal calls (from other actions).
But each action happens only once during one external invocation.

Actions are run within the context of the current object. And _old_ object is available for developers
to use.

Read [actions](/d3e/actions) for more details on what you can do with actions.

### Transient

Transient models are not saved into the database. They are usually used to send a request to the server and perform some action.

Transient models also can have actions, but only OnCreate will be invoked. OnUpdate or OnDelete will not be available as they are not saved at all.

So basically transient models can be used to send some data to the server, and perform some action using that data.

But Validations will be checked even for these models.

### Master

Imagine a Model Contact and it has a child property called address, which is of type Address.

If we are writing an expression in which we have an object of type Address.

We know that "address" is a child of "contact." So, if we want to access Contact from Address, we use master properties.
These properties are similar to normal properties, but they will be automatically created by the system.

### Master Properties

Imagine a Model `Contact` and it has a child property called `address` which is of type `Address`.

If we are writing an expression in which we have an object of type `Address`.

We know that `Address` is a child of `Contact`. So if we want to access `Contact` from `Address` we use _master_ properties.

These properties are similar to normal properties, but they will be automatically created by the system.

```Dart

class Contact {
  String get name;
  Address get address;
}

class Address {
  String get city;
  Contact get masterContact; // this is created by the system.
}

Address add;// assume we got it from somewhere
Contact c = add.masterContact; // we can get its master like this.

```

Master properties/fields will be created only if the current model is used as a child. If it is used as reference then master properties will not be created/present.

If more than one model uses current model as child, then both(all) masters will be created.

```Dart

class Contact {
  Address get address; //assume it is child here
}
class Office {
  Address get address;// assume this is also child
}
class Address {
  Contact get masterContact;// created due to Contact.address
  Office get masterOffice; //created due to Office.address
}
Address add = Address();
Contact c = add.masterContact; // c will be null
Office o = add.masterOffice; // o will be null

Office o1 = Office();
o1.address = add;
Contact c = add.masterContact; // c will be null
Office o = add.masterOffice; // o will be o1

```

## Saving Model Object from Component

You can save model object from a component by following the steps given below

<img src="/images/modelobject.png" class="team">

1. Navigate to the design section
2. Select a component that you want to work on
3. On the right side click on the bell icon to view available model objects
4. Select from the list of objects as for your need
   a. Following the above action, a code console will popup which allows you to write code to Save data into model

## Model Property – References

We can get a list of items from somewhere else in a model. But we can't create items in a model. If already created items exist, then they will show up, or else they won't show items in a model. That we can use as reference in Model Property.

## Reference Properties & Child Properties

A property in a model that refers to another property of a model is called a reference property. (Or) simply other than primitive properties in a model we call "Reference Properties."

Reference properties exist independently, and a reference property method is used to link values from one page to another page.

Child Properties are the properties which inherit or borrow properties from other models. Child properties don’t exist independently.

When we save the parent, the child property inherently gets those changes.

## Inverse Properties

We call a property an Inverse property when we make changes to a model property, those changes should be reflected in child properties.

Note: Make sure you select the Inverse check box in the property's Advanced Setting.

Example: Say a company model has a property named user. If we use a user property as a reference to any other model and make any changes, those changes should be reflected in the company model.

## Core Models

Core models are predefined in D3E models. You can access and use them in your projects by following the steps.

<img src="/images/coremodels.png" class="team">

1. Navigate to the data section tab
2. Click on models in data section
3. From the dropdown click on d3e.core
4. You will see a list of core models. Click on any model to view the properties of that model

## Base Session

To keep a user remembered in an application from sign in till sign out we have to store and pass the user information throughout the user activity across pages. This phenomenon is called base session

## Creating a Base session:

To book a session in D3E Studio following code could do the job
CurrentUser.getsession [login/logout]

## Default Values in Model Properties

Following are the default values for the Model Properties

<img src="/images/modelpropertiestable.png" class="team">

## Exit-ifs in a Model Property

While creating or editing model properties, we will find an Exists-if input field. This exists if the input field has some condition which returns either ‘True’ or ‘False’.

If the condition in this input field returns True, then only the property will hold the value, else it will hold a default value like ‘0’ for an integer property, 'False’ for a Boolean property, etc.

## Permissions for Models & Queries

You want to grant users permission so that they can only perform certain conditions. You can do so in D3E Studio by following these steps.

<img src="/images/permissions.png" class="team">

1. Click on permissions in the Data Section
2. Select a user type from the list in permissions submenu
3. Click on model access section
4. Allocate permissions as suited for the application
