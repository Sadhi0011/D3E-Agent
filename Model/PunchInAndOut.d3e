(Model PunchInAndOut {
    name 'Punch In And Out'
    master #Employee
    allowDynamicReport true
    package 'rewa.hr.2'
    properties [
        (inDate {
            name 'In Date'
            type ({
                primitive Date
            })
        })
        (inTime {
            name 'In Time'
            type ({
                primitive Time
            })
        })
        (inNotes {
            name 'In Notes'
            type ({
                primitive String
            })
        })
        (outTime {
            name 'Out Time'
            type ({
                primitive Time
            })
        })
        (outDate {
            name 'Out Date'
            type ({
                primitive Date
            })
        })
        (outNotes {
            name 'Out Notes'
            type ({
                primitive String
            })
        })
        (duration {
            name 'Duration'
            type ({
                primitive Duration
            })
        })
        (sheet {
            name 'Sheet'
            type ({
                model #AttendanceSheet
            })
        })
        (inLocation {
            name 'In Location'
            type ({
                primitive Geolocation
            })
            child true
        })
        (outLocation {
            name 'Out Location'
            type ({
                primitive Geolocation
            })
            child true
        })
        (isAutoPunchOut {
            type ({
                primitive Boolean
            })
        })
        (isEditable {
            type ({
                primitive Boolean
            })
        })
    ]
    actions [
        (SetAttendanceSheet {
            name 'SetAttendanceSheet'
            block ```
                if(isEditable){
                    if(sheet != null && inDate != null && inTime!= null && outTime != null) {
                        AttendancePerDayRecord toUpdate = AttendancePerDayRecord(
                            date: inDate,
                            records: [
                                this
                            ],
                            startTime: inTime,
                            endTime: outTime,
                            duration: outTime.difference(inTime),
                        );
                        sheet.perDayRecords.add(toUpdate);
                        AutoPunchOutUtils.updatePerDayRecord(this, this.sheet, toUpdate); 
                    }  
                }else {
                    // Get employee timezone 
                    String timezone = employee.location?.timeZone ?? 'UTC(GMT+00:00) Default';
                    DateTime currentDate = TimeZoneUtil.getCurrentDateInTimeZone(timezone);
                    // Assign this sheet
                    this.inDate = currentDate.date;
                    this.inTime = currentDate.time;
                    this.sheet = AttendanceSheetUtil.createAttendanceSheetForEmployee(employee, inDate: this.inDate, inTime: this.inTime);
                    // Sheet is extracted or created. Add per day record for this PunchInAndOut.
                    // endTime will be provided when this object is updated with outDate and outTime
                    sheet.perDayRecords.add(AttendancePerDayRecord(
                        date: inDate,
                        records: [
                            this
                        ],
                        startTime: inTime,
                    ));
                    Database.save(sheet);
                }
            ```
        })
        (UpdateDurationAndAttendanceSheet {
            runOn OnUpdate
            name 'UpdateDurationAndAttendanceSheet'
            block ```
                // Get employee timezone 
                try {
                    String timezone = employee.location?.timeZone ?? 'UTC(GMT+00:00) Default';
                    DateTime currentDate = TimeZoneUtil.getCurrentDateInTimeZone(timezone);
                    DateTime in = DateTime(inDate.year, inDate.month, inDate.dayOfMonth, inTime.hour, inTime.minutes, inTime.seconds, inTime.millisecond);
                    Date systemOutDate = currentDate.date;
                    Time systemOutTime = currentDate.time;
                    DateTime out = DateTime(systemOutDate.year, systemOutDate.month, systemOutDate.dayOfMonth, systemOutTime.hour, systemOutTime.minutes, systemOutTime.seconds, systemOutTime.millisecond);
                    if (isAutoPunchOut){
                        out = DateTime(outDate.year, outDate.month, outDate.dayOfMonth, outTime.hour, outTime.minutes, outTime.seconds, outTime.millisecond);
                        systemOutTime = outTime;
                    }

                    this.outDate = out.date;
                    this.outTime = systemOutTime;
                    // Check if AttendancePerDayRecords exists for inDate
                    List<AttendancePerDayRecord> records = this.sheet.perDayRecords.where((r) => r.date == inDate && r.endTime == null);
                    
                    // There must exactly be one such record
                    AttendancePerDayRecord toUpdate = records.first;

                    if(toUpdate == null) {
                        toUpdate = AttendancePerDayRecord(
                            date : this.inDate,
                            startTime : this.inTime,
                        );
                        this.sheet.perDayRecords.add(toUpdate);
                    }
                
                    this.duration = out.difference(in);
                    Integer numSeconds = this.duration.inSeconds;

                    Duration totalDuration = Duration();
                    for (AttendancePerDayRecord rec in this.sheet.perDayRecords) {
                        if (rec.duration != null) {
                            totalDuration = totalDuration + rec.duration;
                        }
                    }

                    totalDuration = totalDuration + this.duration;

                    Date current = toUpdate.date;
                    /*
                        Case 1: numSeconds is more than the number of seconds in the day - Fill up current record and create a new one, and continue the loop
                        Case 2: numSeconds is less than or equal to number of seconds in the day - Fill up current record
                    */
                    while (numSeconds > 0) {
                        DateTime dayStart = AttendanceUtils.fromDateAndTime(toUpdate.date, toUpdate.startTime);    // The day
                        DateTime dayEnd = DateUtil.fromDateAndTimePieces(toUpdate.date, 23, 59, 59, 999);   // Just before the next day
                
                        Duration dayDuration = dayEnd.difference(dayStart);
                        Integer secondsLeftInDay = dayDuration.inSeconds;
                        if (numSeconds <= secondsLeftInDay) {
                            toUpdate.endTime = systemOutTime;
                            toUpdate.duration = toUpdate.endTime.difference(toUpdate.startTime);
                            toUpdate.records = [
                                this
                            ];
                            Database.save(toUpdate); //save each day's record
                        } else {
                            toUpdate.endTime = dayEnd.time;
                            toUpdate.duration = toUpdate.endTime.difference(toUpdate.startTime);
                            toUpdate.records = [this];
                            Database.save(toUpdate);

                            current = current.plusDays(1);
                            toUpdate = AttendancePerDayRecord(
                                date: current,
                                records: [
                                    this
                                ],
                                startTime: Time.of(0, 0, 0, 0),
                            );
                            this.sheet.perDayRecords.add(toUpdate);
                        }
                        numSeconds -= secondsLeftInDay;
                    }

                    this.sheet.totalTime = totalDuration;

                    String country = employee?.job?.location?.country ?? null;
                    if (this.sheet.payPolicy != null && country != null) {
                        // PayPolicy is explicitly set. So calculate PayCodeTimes
                        // For now, only Working days
                        List<WorkWeek> workWeeks = Database.getWorkWeeksInCountry(
                            country: country
                        );
                        if (workWeeks.length == 1) {
                            WorkWeek ww = workWeeks.first;
                            Map<Date, Double> hoursPerDay = Map();
                            for (AttendancePerDayRecord rec in this.sheet.perDayRecords) {
                                Date date = rec.date;
                                if (!hoursPerDay.containsKey(date)) {
                                    hoursPerDay.set(date, 0.0);
                                }
                                Double mins = rec.duration.inMinutes.floorToDouble();
                                hoursPerDay.set(date, hoursPerDay.get(date) + (mins / 60));
                            }
                            hoursPerDay.forEach((d, hrs) {
                                // TODO: Switch based on working day, etc.
                                PayPolicyRuleType dc = DateUtil.getDayCycle(d, ww);
                                List<PayCodeTime> times = this.sheet.payCodeTimes.where(t => t.rule.type == dc);
                                PayCodeTime untilTime = times.firstWhere(t => !t.rule.after);
                                List<PayCodeTime> afterTimes = times.where(t => t.rule.after).toList().orderBy((t) => t.rule.hours);
                                // Handle untilTime
                                if(untilTime != null) {
                                    if (untilTime.rule.hours >= hrs) {
                                        untilTime.time = Duration(hours: hrs.floor());
                                    } else {
                                        // More than required time
                                        untilTime.time = Duration(hours: untilTime.rule.hours);
                                        for (PayCodeTime time in afterTimes) {
                                            Double extra = hrs - time.rule.hours;
                                            if (extra <= 0.0) {
                                                // No extra time matches this PayCodeTime. And the list is sorted, so the next values won't match either
                                                break;
                                            }
                                            time.time = Duration(hours: extra.floor());
                                        }
                                    }
                                }
                            });
                        }
                    }
                    Database.save(this.sheet);
                } catch (e) {
                    Log.error('Error in UpdateDurationAndAttendanceSheet: ' + e.toString());
                }
            ```
        })
        (OnDeleteRecord {
            runOn OnDelete
            block ```
                if(sheet != null){
                    List<AttendancePerDayRecord> toDelete = sheet.perDayRecords.where((r) => r.records.contains(this)).toList();
                    Duration totalDuration = Duration();
                    for(AttendancePerDayRecord rec in toDelete){
                        totalDuration = totalDuration + rec.duration;
                        sheet.perDayRecords.remove(rec);
                        Database.delete(rec);
                    }
                    sheet.totalTime = sheet.totalTime - totalDuration;
                    Database.save(sheet);
                }
            ```
        })
    ]
})
